package {{.PrimaryEntity}}

import (
	"context"
	"log/slog"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

type Handler struct {
	service Service
	logger  *slog.Logger
}

type Service interface {
	Create{{.EntityCapitalized}}(ctx context.Context, req Create{{.EntityCapitalized}}Request) (*{{.EntityCapitalized}}, error)
	List{{.EntityPlural}}(ctx context.Context, limit, offset int) ([]*{{.EntityCapitalized}}, int64, error)
	Get{{.EntityCapitalized}}(ctx context.Context, id uuid.UUID) (*{{.EntityCapitalized}}, error)
	Update{{.EntityCapitalized}}(ctx context.Context, id uuid.UUID, req Update{{.EntityCapitalized}}Request) (*{{.EntityCapitalized}}, error)
	Delete{{.EntityCapitalized}}(ctx context.Context, id uuid.UUID) error
}

func NewHandler(service Service, logger *slog.Logger) *Handler {
	return &Handler{
		service: service,
		logger:  logger,
	}
}

func (h *Handler) Create{{.EntityCapitalized}}(c *gin.Context) {
	var req Create{{.EntityCapitalized}}Request
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("failed to bind request", slog.String("error", err.Error()))
		c.JSON(400, gin.H{"error": "Invalid request body", "details": err.Error()})
		return
	}

	item, err := h.service.Create{{.EntityCapitalized}}(c.Request.Context(), req)
	if err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(201, item)
}

func (h *Handler) List{{.EntityPlural}}(c *gin.Context) {
	limitStr := c.DefaultQuery("limit", "20")
	offsetStr := c.DefaultQuery("offset", "0")

	limit, err := strconv.Atoi(limitStr)
	if err != nil {
		limit = 20
	}

	offset, err := strconv.Atoi(offsetStr)
	if err != nil {
		offset = 0
	}

	items, total, err := h.service.List{{.EntityPlural}}(c.Request.Context(), limit, offset)
	if err != nil {
		c.JSON(500, gin.H{"error": "Failed to list {{.EntityPlural}}"})
		return
	}

	response := List{{.EntityPlural}}Response{
		{{.EntityPlural}}: items,
		Total:    total,
		Limit:    limit,
		Offset:   offset,
	}

	c.JSON(200, response)
}

func (h *Handler) Get{{.EntityCapitalized}}(c *gin.Context) {
	idStr := c.Param("id")
	if idStr == "" {
		c.JSON(400, gin.H{"error": "{{.PrimaryEntity}} ID is required"})
		return
	}

	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(400, gin.H{"error": "invalid {{.PrimaryEntity}} ID"})
		return
	}

	item, err := h.service.Get{{.EntityCapitalized}}(c.Request.Context(), id)
	if err != nil {
		c.JSON(404, gin.H{"error": "{{.EntityCapitalized}} not found"})
		return
	}

	c.JSON(200, item)
}

func (h *Handler) Update{{.EntityCapitalized}}(c *gin.Context) {
	idStr := c.Param("id")
	if idStr == "" {
		c.JSON(400, gin.H{"error": "{{.PrimaryEntity}} ID is required"})
		return
	}

	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(400, gin.H{"error": "invalid {{.PrimaryEntity}} ID"})
		return
	}

	var req Update{{.EntityCapitalized}}Request
	if err := c.ShouldBindJSON(&req); err != nil {
		h.logger.Error("failed to bind request", slog.String("error", err.Error()))
		c.JSON(400, gin.H{"error": "Invalid request body", "details": err.Error()})
		return
	}

	item, err := h.service.Update{{.EntityCapitalized}}(c.Request.Context(), id, req)
	if err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, item)
}

func (h *Handler) Delete{{.EntityCapitalized}}(c *gin.Context) {
	idStr := c.Param("id")
	if idStr == "" {
		c.JSON(400, gin.H{"error": "{{.PrimaryEntity}} ID is required"})
		return
	}

	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(400, gin.H{"error": "invalid {{.PrimaryEntity}} ID"})
		return
	}

	if err := h.service.Delete{{.EntityCapitalized}}(c.Request.Context(), id); err != nil {
		h.logger.Error("failed to delete {{.PrimaryEntity}}",
			slog.String("error", err.Error()),
			slog.String("id", id.String()))
		c.JSON(500, gin.H{"error": "Failed to delete {{.PrimaryEntity}}"})
		return
	}

	c.Status(204)
}